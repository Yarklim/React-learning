Управление состоянием
Требования к функционалу приложений постоянно растут, в результате увеличивается количество состояний интерфейса: асинхронная загрузка данных, индикаторы загрузки данных, значения фильтров при сортировке, состояние форм и т. п. Библиотеки управления состоянием стандартизируют хранение и работу с состоянием приложения, тем самым упрощая процесс разработки.

split-bundle
Redux это одна из самых популярных библиотек управления состоянием приложения.

Предсказуемость результата - существует всегда один источник правды, стор (хранилище, store), скрывающее в себе состояние приложения и методы для работы с ним.
Поддерживаемость - есть набор правил и лучших практик о том, как должен быть структурирован код, что делает его более единообразным и понятным.
Инструменты разработчика - удобное расширение браузера в котором предоставляется максимум информации о состоянии приложения в режиме реального времени.
Поток данных
no-redux-vs-redux
Без использования библиотеки управления состоянием процесс обновления данных выглядит следующим образом:

Состояние хранится в ближайшем общем компоненте предке.
Какой-то вложенный компонент инициализирует изменение состояния вызвав метод полученный как пропс.
Измененное состояние пробрасывается пропсами вниз по дереву компонентов.
Посмотрите на анимированную иллюстрацию этого процесса, на которой показан пример изменения состояния в разных частях приложения.

state change without redux
Некоторых компоненты выступают проводниками, то есть получают пропс только для того чтобы пробросить его еще глубже, до компонента которому он действительно нужен. Сначала нужно пробросить через все дерево компонентов метод изменения состояния, потом само состояние. Это стандартный механизм передачи пропсов на несколько уровней в глубину, изменить его нельзя.

Redux решает эту проблему созданием стора (хранилища, store), который отвечает за централизованное хранение всего состояния и предоставляет набор правил и методов для его изменения. Компонентам остается вызвать методы для обновления данных и подписаться на обновления. Таким образом Redux решает проблему передачи пропсов через все дерево компонентов.

state change with redux
Поток данных в Redux всегда однонаправленный, от компонентов к стору, и от стора к компонентам, без посредников. Это делает логику приложения более предсказуемой и легкой для понимания.

Redux data flow
Пользователь, работая с интерфейсом, инициализирует отправку экшенов (действий, actions).
Стор (store) вызывает все объявленные редюсеры (reducers), функции для изменения состояния, передавая им текущее состояние (state) и экшен (действие, action).
Стор (store) сохраняет обновленное состояние (state) возвращенное из редюсеров (reducers).
При обновлении состояния (state) повторно рендерятся зависимые от него компоненты.
Плюсы и минусы
Redux это всего лишь инструмент для управления состоянием приложения, который предназначен для того, чтобы помочь ответить на вопрос - «Когда и как изменилась определенная часть состояния». Если у вас нет проблем с управлением состоянием используя возможности React, вам может быть труднее понять преимущества Redux. Может быть состояние React это все, что вам нужно для создания приложения.

Необходимость использовать библиотеку управления состоянием не следует воспринимать как должное. Если приложение становится настолько сложным, что вы не понимаете, где хранится состояние, как оно изменяется, и вы обнаружите, что хранения данных в состоянии компонента React уже недостаточно, тогда самое время использовать Redux.

Тем не менее, использование Redux требует компромиссов. Он не создан чтобы быть самым коротким или быстрым способом написания кода. Redux накладывает определенные требования: хранить состояние приложения в виде простой структуры данных (стор), описывать изменения объектами (экшены) и обрабатывать эти изменения с помощью чистых функций (редюсеры).

Планировщик задач
Будем разбирать Redux на примере приложения планировщика задач, в котором можно создать, удалить, отметить задачу как выполненную и отфильтровать задачи по статусу. Это позволит нам рассмотреть стандартные случаи при работе с коллекцией данных.

В первую очередь пропишем базовые требования к интерфейсу и логике работы приложения:

Интерфейс должен состоять из нескольких частей:
Шапка с информацией о задачах и фильтрами
Форма с полем ввода для создания новых задач
Список задач
В шапке необходимо отображать:
Количество выполненных и невыполненных задач
Фильтры списка задач со значениями «All», «Active» и «Completed»
У каждого элемента списка задач должен быть:
Абзац с текстом который вводил в форму пользователь при создании задачи
Чекбокс переключения статуса «выполнено»
Кнопка удаления задачи
Конечная цель - приложение, интерфейс которого будет выглядеть так.

Example task manager app UI
Проектирование состояния
Интерфейс приложения должен основываться на его состоянии. Поэтому в первую очередь необходимо спроектировать состояние приложения, которое будет содержать наименьшее количество значений, достаточное для описания всего необходимого функционала. Это сократит количество данных за которыми необходимо будет следить и обновлять.

В нашем приложении есть две основные части: список задач, из которого можно получить все необходимые данные о количестве и статусе задач, и значения фильтров списка задач. Это и будет минимально необходимое состояние.

const appState = {
  tasks: [],
  filters: {
    status: "all",
  },
};

СТРУКТУРА СОСТОЯНИЯ
Состояние Redux это всегда объект, внутрь которого добавляются свойства для состояния приложения. Поэтому мы объявили свойство tasks для массива всех задач и filters для возможных фильтров. Состояние Redux может быть настолько простое или сложное, насколько этого требует функционал приложения.

Каждая задача будет представлена объектом со следующими свойствами:

id - уникальный идентификатор
text - текст, который ввел пользователь при создании
completed - флаг, указывающий, выполнена задача или нет
Вот как может выглядеть пример состояния нашего приложения с несколькими задачами:

const appState = {
  tasks: [
    { id: 0, text: "Learn HTML and CSS", completed: true },
    { id: 1, text: "Get good at JavaScript", completed: true },
    { id: 2, text: "Master React", completed: false },
    { id: 3, text: "Discover Redux", completed: false },
    { id: 4, text: "Build amazing apps", completed: false },
  ],
  filters: {
    status: "all",
  },
};

Проектирование экшенов
Экшены это события которые могут произойти в приложении, в том числе как реакция на действия пользователя. Составим список событий которые могут быть в нашем приложении:

Добавить новую задачу с текстом, введенным пользователем
Удалить задачу
Переключить статус задачи
Изменить значение фильтра статуса
Структура файлов проекта
В Redux нет стандарта структуры файлов проекта, только общие рекомендации и примеры, поэтому каждый может выбрать что-то для себя. Тем не менее, важно продумать шаблон структуры файлов проекта еще до написания кода.

Для того чтобы отделить логику Redux от кода компонентов нам будет достаточно сделать папку src/redux с несколькими файлами. В небольшом приложении, как наш планировщик задач, этого будет достаточно.

Example task manager app file structure
actions.js - файл объявления экшенов приложения
reducer.js - файл объявления функций-редюсеров для обновления состояния
constants.js - файл для хранения констант (например значений фильтра статуса)
selectors.js - файл объявления функций-селекторов
store.js - файл создания стора Redux
Если в приложении много разных данных, то подойдет «feature based» подход, где под каждую сущность создается отдельная папка внутри папки redux. Внутри каждой сущности есть стандартный набор файлов. В результате больше файлов, но код логики Redux разделен на сущности и более структурирован.

Example task manager app file structure
Стартовый код
В этой песочнице вы можете взять стартовый код планировщика задач с уже готовыми компонентами React и дополнять его логикой Redux параллельно изучению материала.

Установка
Добавим в проект библиотеку Redux - набор функций для создания стора (хранилища, store), работы с состоянием приложения (state) и отправки экшенов (действий, actions).

npm install redux

Для использования React и Redux вместе, необходимо добавить в проект библиотеку React Redux. Это набор компонентов и хуков связывающих компоненты React и Redux стор (store).

npm install react-redux

REDUX VS REDUX TOOLKIT
В материалах этого занятия мы познакомимся с основополагающими концепциями библиотеки Redux и обязательно разберем их на живых примерах. Но, в дальнейшем мы будем использовать Redux Toolkit - надстройку над базовыми концепциями и конструкциями Redux, которая основана на лучших практиках, упрощает код связанный с Redux и предотвращает распространенные ошибки. Это официальный рекомендуемый подход для написания логики Redux.

Стор (store)
Объект, который содержит полное состояние приложения, методы доступа к состоянию и отправки экшенов. В приложении может быть только один стор. Для создания стора есть функция createStore(), которая принимает несколько параметров и возвращает новый объект стора.

createStore(reducer, preloadedState, enhancer)

reducer - функция с логикой изменения состояния Redux. Обязательный параметр.
preloadedState - начальное состояние приложения. Это должен быть объект той же формы, что и, как минимум, часть состояния. Необязательный параметр.
enhancer - функция расширения возможностей стора. Необязательный параметр.
src/redux/store.js
import { createStore } from "redux";
// Начальное значение состояния Redux для корневого редюсера,
// если не передать параметр preloadedState.
const initialState = {
  tasks: [
    { id: 0, text: "Learn HTML and CSS", completed: true },
    { id: 1, text: "Get good at JavaScript", completed: true },
    { id: 2, text: "Master React", completed: false },
    { id: 3, text: "Discover Redux", completed: false },
    { id: 4, text: "Build amazing apps", completed: false },
  ],
  filters: {
    status: "all",
  },
};
// Пока что используем редюсер который
// только возвращает полученное состояние
const rootReducer = (state = initialState, action) => {
  return state;
};
export const store = createStore(rootReducer);

После создания стора необходимо связать его с компонентами React, чтобы они могли получать доступ к стору и его методам. Для этого в библиотеке React Redux есть компонент Provider, который ожидает одноименный пропс store. Для того чтобы любой компонент в приложении мог использовать стор, оборачиваем Provider все дерево компонентов.

src/index.js
import ReactDOM from "react-dom/client";
import { Provider } from "react-redux";
import { store } from "./redux/store";
ReactDOM.createRoot(document.getElementById("root")).render(
  <Provider store={store}>
    <App />
  </Provider>
);

Redux DevTools
Инструменты разработчика это расширение браузера которое добавляет удобный визуальный интерфейс для отладки изменений состояния приложения и слежения за потоком данных в Redux, от отправки действий и до изменения состояния.

Для начала необходимо добавить расширение инструментов разработчика в ваш браузер:

Chrome Web Store
Firefox Add-ons
Edge Add-ons
Далее устанавливаем библиотеку которая позволит инициализировать логику Redux DevTools и связать ее с расширением в инструментах разработчика.

npm install @redux-devtools/extension

Мы пока что не используем никаких дополнительных продвинутых возможностей Redux, поэтому импортируем функцию devToolsEnhancer и используем её при создании стора, передав её результат третьим аргументом, вместо начального состояния.

src/redux/store.js
import { createStore } from "redux";
import { devToolsEnhancer } from "@redux-devtools/extension";
const initialState = {
  tasks: [
    { id: 0, text: "Learn HTML and CSS", completed: true },
    { id: 1, text: "Get good at JavaScript", completed: true },
    { id: 2, text: "Master React", completed: false },
    { id: 3, text: "Discover Redux", completed: false },
    { id: 4, text: "Build amazing apps", completed: false },
  ],
  filters: {
    status: "all",
  },
};
const rootReducer = (state = initialState, action) => {
  return state;
};
// Создаем расширение стора чтобы добавить инструменты разработчика
const enhancer = devToolsEnhancer();
export const store = createStore(rootReducer, enhancer);

ПОРЯДОК АРГУМЕНТОВ
Если вам не нужно начальное состояние preloadedState, то значение enhancer передается вторым аргументом. В противном случае - третьим.

После запуска проекта командой npm start, в стандартных инструментах разработчика появится новая вкладка Redux, при переходе на которую откроются Redux DevTools со списком отправленных экшенов слева и детальной информацией о состоянии и экшенах справа.

Redux DevTools extension UI

Подписка на стор
Чтобы получить данные из стора, компоненты должны подписаться на необходимые им части состояния Redux. Для этого в библиотеке React Redux есть хук useSelector(selector). Аргументом он принимает функцию, которая объявляет один параметр state - весь объект состояния Redux, который будет автоматически передан функции хуком useSelector. Эта функция называется селектор и должна вернуть только ту часть состояния, которая необходима компоненту.

// Импортируем хук
import { useSelector } from "react-redux";
const MyComponent = () => {
  // Получаем необходимую часть состояния
  const value = useSelector(state => state.some.value);
};

Добавим код подписки компонентов нашего приложения. Для того чтобы сфокусировать внимание на логике кода подписки, в примерах опустим стилизацию. Полный код приложения вы можете разобрать на живом примере в конце этой секции.

Фильтр по статусу
Сохраним возможные значения фильтра в виде объекта, чтобы повторно использовать их в разных местах приложения: компоненте StatusFilter для вычисления текущего активного фильтра и отправки экшенов изменения фильтра, компоненте TaskList для вычисления списка видимых задач, а также функции-редюсере в которой потом будем обрабатывать экшен изменения фильтра.

src/redux/constants.js
export const statusFilters = Object.freeze({
  all: "all",
  active: "active",
  completed: "completed",
});

OBJECT.FREEZE()
Используем метод Object.freeze() для того, чтобы «заморозить» объект значений фильтра и предотвратить случайное его изменение по ссылке в местах импорта.

Компоненту StatusFilter нужно значение фильтра из свойства statusFilter состояния Redux, поэтому функция-селектор будет выглядеть как state => state.filters.status.

src/components/StatusFilter/StatusFilter.js
// Импортируем хук
import { useSelector } from "react-redux";
// Импортируем объект значений фильтра
import { statusFilters } from "../../redux/constants";
export const StatusFilter = () => {
  // Получаем значение фильтра из состояния Redux
  const filter = useSelector(state => state.filters.status);
  return (
    <div>
      <Button selected={filter === statusFilters.all}>All</Button>
      <Button selected={filter === statusFilters.active}>Active</Button>
      <Button selected={filter === statusFilters.completed}>Completed</Button>
    </div>
  );
};

Список задач
Компоненту TaskList необходим массив задач из свойства tasks и значение фильтра из свойства statusFilter. На базе этих значений мы можем высчитать массив задач которые необходимо рендерить в интерфейсе.

src/components/TaskList/TaskList.js
// Импортируем хук
import { useSelector } from "react-redux";
import { Task } from "components/Task/Task";
// Импортируем объект значений фильтра
import { statusFilters } from "../../redux/constants";
const getVisibleTasks = (tasks, statusFilter) => {
  switch (statusFilter) {
    case statusFilters.active:
      return tasks.filter(task => !task.completed);
    case statusFilters.completed:
      return tasks.filter(task => task.completed);
    default:
      return tasks;
  }
};
export const TaskList = () => {
  // Получаем массив задач из состояния Redux
  const tasks = useSelector(state => state.tasks);
  // Получаем значение фильтра из состояния Redux
  const statusFilter = useSelector(state => state.filters.status);
  // Вычисляем массив задач которые необходимо отображать в интерфейсе
  const visibleTasks = getVisibleTasks(tasks, statusFilter);
  return (
    <ul>
      {visibleTasks.map(task => (
        <li key={task.id}>
          <Task task={task} />
        </li>
      ))}
    </ul>
  );
};

ГДЕ ПРОПСЫ?
Обратите внимание на то, что у компонента TaskList нет пропсов, как это было бы при использовании состояния React. Компоненту App теперь не нужно знать о том, что TaskList подписан на данные из стора. Используя Redux любой компонент может напрямую получить доступ к значениям из состояния Redux, если в этом есть необходимость.

Счетчик задач
Компоненту TaskCounter необходим массив задач из свойства tasks состояния Redux, поэтому функция-селектор будет выглядеть как state => state.tasks. На базе этих данных мы можем вычислить производные данные количества активных и выполненных задач.

src/components/TaskCounter/TaskCounter.js
// Импортируем хук
import { useSelector } from "react-redux";
export const TaskCounter = () => {
  // Получаем массив задач из состояния Redux
  const tasks = useSelector(state => state.tasks);
  // На базе состояния Redux получаем производные данные
  const count = tasks.reduce(
    (acc, task) => {
      if (task.completed) {
        acc.completed += 1;
      } else {
        acc.active += 1;
      }
      return acc;
    },
    { active: 0, completed: 0 }
  );
  return (
    <div>
      <p>Active: {count.active}</p>
      <p>Completed: {count.completed}</p>
    </div>
  );
};

Функции-селекторы
Один и тот же селектор может использоваться в нескольких местах приложения, что приводит к дублированию кода, как например в наших компонентах TaskList, StatusFilter и TaskCounter. Чтобы избежать этого и еще больше структурировать код, все функции-селекторы объявляются в отдельном файле, например в src/redux/selectors.js, после чего импортируются в компоненты.

src/redux/selectors.js
export const getTasks = state => state.tasks;
export const getStatusFilter = state => state.filters.status;

ОДИН ИСТОЧНИК ПРАВДЫ
Объявление функций-селекторов вне компонентов также хорошо тем, что компоненты не знают о форме состояния Redux, и в случае его изменения достаточно будет отредактировать код одного файла, а не искать селекторы по коду всех компонентов приложения.

Планировщик задач
Разберите живой пример нашего приложения. На данный момент в приложении реализована инициализация стора с инструментами разработчика и подписка компонентов на стор. Следующим шагом будет добавление отправки экшенов.

Экшены (actions)
Экшены - это объекты, которые передают данные из компонентов в стор, тем самым сигнализируя о том, какое событие произошло в интерфейсе. Они являются единственным источником информации для стора.

const action = {
  type: "Action type",
  payload: "Payload value",
};

Экшены должны иметь обязательное свойство type - строку которая описывает тип события в интерфейсе. Помимо свойства type структура объекта может быть произвольной, тем не менее, данные обычно передают в необязательном свойстве payload. Данными экшена может быть любое значение кроме функций и классов.

Создадим экшены которые будут описывать добавление, удаление и переключение статуса задачи, а также изменение значения фильтра.

const addTask = {
  type: "tasks/addTask",
  payload: {
    id: "Generated id",
    text: "User entered text",
    completed: false,
  },
};
const deleteTask = {
  type: "tasks/deleteTask",
  payload: "Task id",
};
const toggleCompleted = {
  type: "tasks/toggleCompleted",
  payload: "Task id",
};
const setStatusFilter = {
  type: "filters/setStatusFilter",
  payload: "Filter value",
};

ЛУЧШИЕ ПРАКТИКИ - ИМЕНОВАНИЕ
Одна из наиболее популярных конвенций составления типа экшена предлагает использовать в значении поля type две части в формате domain/eventName. Первое это имя категории (сущности) к которой принадлежит экшен (tasks и filters), обычно совпадает с именем свойства части состояния Redux, и второе это событие которое описывает экшен (addTask, deleteTask, toggleCompleted, setStatusFilter).

ЛУЧШИЕ ПРАКТИКИ - МИНИМАЛИЗМ
Экшены должны нести в себе минимально необходимый набор информации, которого будет достаточно для изменения состояния. Например, при удалении задачи достаточно передать её идентификатор, а не весь объект задачи целиком.

Генераторы экшенов
Экшены это статические объекты, значение свойства payload которых невозможно задать динамически. Генераторы экшенов (Action Creators) - функции, которые могут принимать аргументы, после чего создают и возвращают экшены с одинаковым значением свойства type, но разными payload. Они могут иметь побочные эффекты, например заполнять свойства по умолчанию или генерировать уникальный идентификатор для объекта задачи. Создадим генераторы экшенов для нашего приложения.

src/redux/actions.js
import { nanoid } from "nanoid";
export const addTask = text => {
  return {
    type: "tasks/addTask",
    payload: {
      id: nanoid(),
      completed: false,
      text,
    },
  };
};
export const deleteTask = taskId => {
  return {
    type: "tasks/deleteTask",
    payload: taskId,
  };
};
export const toggleCompleted = taskId => {
  return {
    type: "tasks/toggleCompleted",
    payload: taskId,
  };
};
export const setStatusFilter = value => {
  return {
    type: "filters/setStatusFilter",
    payload: value,
  };
};

УНИКАЛЬНЫЙ ИДЕНТИФИКАТОР ЗАДАЧИ
Обратите внимание на генератор экшенов создания задачи addTask. В будущем присвоением идентификатора будет заниматься бэкенд, а пока что сделаем это в нашем коде. Для этого используем библиотеку nanoid.

Отправка экшенов
Для того чтобы оповестить стор о том, что в интерфейсе произошло какое-то событие, необходимо отправить экшен. Для этого в библиотеке React Redux есть хук useDispatch(), который возвращает ссылку на функцию отправки экшенов dispatch из объекта созданного нами ранее стора Redux.

// Импортируем хук
import { useDispatch } from "react-redux";
const MyComponent = () => {
  // Получаем ссылку на функцию отправки экшенов
  const dispatch = useDispatch();
};

Добавим код отправки ранее спроектированных экшенов из компонентов нашего приложения. Для того чтобы сфокусировать внимание на отправке экшенов, в примерах опустим код стилизации. Полный код приложения вы можете разобрать на живом примере в конце этой секции.

Создание задачи
При сабмите формы в компоненте TaskForm необходимо отправить экшен создания новой задачи, передав ему значение введенное пользователем в текстовое поле.

src/components/TaskForm/TaskForm.js
// Импортируем хук
import { useDispatch } from "react-redux";
// Импортируем генератор экшена
import { addTask } from "../../redux/actions";
export const TaskForm = () => {
  // Получаем ссылку на функцию отправки экшенов
  const dispatch = useDispatch();
  const handleSubmit = event => {
    event.preventDefault();
    const form = event.target;
    // Вызываем генератор экшена и передаем текст задачи для поля payload
    // Отправляем результат - экшен создания задачи
    dispatch(addTask(form.elements.text.value));
    form.reset();
  };
  return (
    <form onSubmit={handleSubmit}>
      <input type="text" name="text" placeholder="Enter task text..." />
      <button type="submit">Add task</button>
    </form>
  );
};

При сабмите формы, в списке экшенов слева Redux DevTools, добавляется отправленный экшен создания задачи. Кликнув по нему и выбрав в правой части вкладку Actions, можно посмотреть детальную информацию.

Add task action in redux devtools
Удаление задачи
При клике по кнопке удаления в компоненте Task, необходимо отправить экшен удаления задачи, передав ему идентификатор задачи. Этих данных будет достаточно для удаления задачи из массива объектов.

src/components/Task/Task.js
// Импортируем хук
import { useDispatch } from "react-redux";
// Импортируем генератор экшена
import { deleteTask } from "../../redux/actions";
export const Task = ({ task }) => {
  // Получаем ссылку на функцию отправки экшенов
  const dispatch = useDispatch();
  // Вызываем генератор экшена и передаём идентификатор задачи
  // Отправляем результат - экшен удаления задачи
  const handleDelete = () => dispatch(deleteTask(task.id));
  return (
    <div>
      <input type="checkbox" />
      <p>{task.text}</p>
      <button type="button" onClick={handleDelete}>
        Delete
      </button>
    </div>
  );
};

При клике по кнопке удаления, в Redux DevTools добавляется отправленный экшен удаления задачи. Кликнув по нему, можно посмотреть детальную информацию.

Delete task action in redux devtools
Переключение статуса
При клике по чекбоксу в компоненте Task, необходимо отправить экшен переключения статуса задачи, передав ему идентификатор задачи. Этих данных будет достаточно для того чтобы найти задачу в массиве объектов и изменить значение свойства на противоположное.

src/components/Task/Task.js
// Импортируем хук
import { useDispatch } from "react-redux";
// Импортируем генератор экшена
import { deleteTask, toggleCompleted } from "../../redux/actions";
export const Task = ({ task }) => {
  // Получаем ссылку на функцию отправки экшенов
  const dispatch = useDispatch();
  const handleDelete = () => dispatch(deleteTask(task.id));
  // Вызываем генератор экшена и передаём идентификатор задачи
  // Отправляем результат - экшен переключения статуса задачи
  const handleToggle = () => dispatch(toggleCompleted(task.id));
  return (
    <div>
      <input type="checkbox" onChange={handleToggle} checked={task.completed} />
      <p>{task.text}</p>
      <button onClick={handleDelete}>Delete</button>
    </div>
  );
};

При клике по чекбоксу, в Redux DevTools добавляется отправленный экшен изменения статуса задачи. Кликнув по нему, можно посмотреть детальную информацию.

Toggle task action in redux devtools
БЕЗ ЛИШНИХ ПРОПСОВ
Обратите внимание на то, что у компонента Task нет дополнительных пропсов, например методов для удаления и изменения статуса, как это было бы при использовании состояния React. Это также делает компонент списка задач проще, ему не приходится принимать не нужные пропсы и пробрасывать их в компонент задачи. Используя Redux любой компонент может напрямую получить доступ к функции отправки экшенов.

Изменение фильтра
При клике по кнопкам в компоненте StatusFilter необходимо отправить экшен изменения фильтра, передав ему новое значение. Используем объект значений фильтра из файла констант.

src/components/StatusFilter/StatusFilter.js
// Импортируем хук
import { useSelector, useDispatch } from "react-redux";
// Импортируем генератор экшена
import { setStatusFilter } from "../../redux/actions";
// Импортируем объект значений фильтра
import { statusFilters } from "../../redux/constants";
export const StatusFilter = () => {
  // Получаем ссылку на функцию отправки экшенов
  const dispatch = useDispatch();
  const filter = useSelector(state => state.statusFilter);
  // Вызываем генератор экшена и передаём значение фильтра
  // Отправляем результат - экшен изменения фильтра
  const handleFilterChange = filter => dispatch(setStatusFilter(filter));
  return (
    <div>
      <Button
        selected={filter === statusFilters.all}
        onClick={() => handleFilterChange(statusFilters.all)}
      >
        All
      </Button>
      <Button
        selected={filter === statusFilters.active}
        onClick={() => handleFilterChange(statusFilters.active)}
      >
        Active
      </Button>
      <Button
        selected={filter === statusFilters.completed}
        onClick={() => handleFilterChange(statusFilters.completed)}
      >
        Completed
      </Button>
    </div>
  );
};

При клике по кнопкам фильтра, в Redux DevTools добавляется отправленный экшен изменения фильтра. Кликнув по нему, можно посмотреть детальную информацию.

Set filter action in redux devtools
Планировщик задач
Разберите живой пример нашего приложения. На данный момент в приложении реализована инициализация стора с инструментами разработчика, подписка компонентов на стор и отправка экшенов. Следующим шагом будет добавление логики обновления состояния Redux при помощи функций-редюсеров.

Редюсеры (reducers)
Мы спроектировали состояние приложения, связали компоненты и стор, добавили отправку экшенов. Пришло время написать логику изменения состояния Redux.

Редюсер (reducer) - это функция, которая принимает текущее состояние и экшен в качестве аргументов и возвращает новое состояние. Редюсер определяет, как изменяется состояние приложения в ответ на экшены, отправленные в стор. Помните, что экшены описывают только то, что произошло, а не как изменяется состояние приложения.

(state, action) => nextState

Корневой редюсер
В приложении всегда будет только один корневой редюсер, который необходимо передать в createStore при создании стора. Этот редюсер отвечает за обработку всех отправленных экшенов и вычисление нового состояния.

src/redux/reducer.js
import { statusFilters } from "./constants";
const initialState = {
  tasks: [
    { id: 0, text: "Learn HTML and CSS", completed: true },
    { id: 1, text: "Get good at JavaScript", completed: true },
    { id: 2, text: "Master React", completed: false },
    { id: 3, text: "Discover Redux", completed: false },
    { id: 4, text: "Build amazing apps", completed: false },
  ],
  filters: {
    status: statusFilters.all,
  },
};
// Используем initialState как значение состояния по умолчанию
export const rootReducer = (state = initialState, action) => {
  // Редюсер различает экшены по значению свойства type
  switch (action.type) {
    // В зависимости от типа экшена будет выполняться разная логика
    default:
      // Каждый редюсер получает все экшены отправленные в стор.
      // Если редюсер не должен обрабатывать какой-то тип экшена,
      // необходимо вернуть существующее состояние без изменений.
      return state;
  }
};

НАЧАЛЬНОЕ СОСТОЯНИЕ
При инициализации стора (экшен @@INIT в Redux DevTools) всем редюсерам в качестве значения состояния передается undefined. Поэтому каждому редюсеру нужно указать значение по умолчанию для параметра state, которое станет начальным состоянием приложения.

Добавим логику обработки экшена создания задачи. Проверяем соответствует ли тип отправленного экшена строке "tasks/addTask" и возвращаем новый объект, содержащий все состояние, даже для свойств, которые не изменились.

src/redux/reducer.js
import { statusFilters } from "./constants";
const initialState = {
  tasks: [
    { id: 0, text: "Learn HTML and CSS", completed: true },
    { id: 1, text: "Get good at JavaScript", completed: true },
    { id: 2, text: "Master React", completed: false },
    { id: 3, text: "Discover Redux", completed: false },
    { id: 4, text: "Build amazing apps", completed: false },
  ],
  filters: {
    status: statusFilters.all,
  },
};
export const rootReducer = (state = initialState, action) => {
  // Редюсер различает экшены по значению свойства type
  switch (action.type) {
    // В зависимости от типа экшена будет выполняться разная логика
    case "tasks/addTask": {
      // Нужно вернуть новый объект состояния
      return {
        // в котором есть все данные существующего состояния
        ...state,
        // и новый массив задач
        tasks: [
          // в котором есть все существующие задачи
          ...state.tasks,
          // и объект новой задачи
          action.payload,
        ],
      };
    }
    default:
      // Каждый редюсер получает все экшены отправленные в стор.
      // Если редюсер не должен обрабатывать какой-то тип экшена,
      // необходимо вернуть существующее состояние без изменений.
      return state;
  }
};

ИММУТАБЕЛЬНОСТЬ СОСТОЯНИЯ
Писать логику обновления состояния вручную не самая легкая задача, поэтому случайное изменение состояния в редюсерах это распространенная ошибка. На практике вам не придется писать сложные вложенные иммутабельные обновления вручную. В следующем занятии вы узнаете как использовать Redux Toolkit, чтобы упростить написание логики обновления состояния.

Код файла создания стора импортирует и использует корневой редюсер.

src/redux/store.js
import { createStore } from "redux";
import { devToolsEnhancer } from "@redux-devtools/extension";
import { rootReducer } from "./reducer";
const enhancer = devToolsEnhancer();
export const store = createStore(rootReducer, enhancer);

ОБНОВЛЕНИЕ ИНТЕРФЕЙСА
Если теперь попробовать добавить новую задачу в интерфейсе нашего приложения, то в списке задач отобразится новый элемент. Дело в том, что хук useSelector заставляет компонент рендерится повторно каждый раз при изменении той части состояния на которую подписан компонент.

Правила редюсеров
Редюсеры должны быть чистыми функциями и следовать списку правил:

Нельзя изменять аргументы (state и action). Редюсеры должны только вычислять новое значение состояния на основе этих аргументов.
Нельзя изменять существующее состояние (state). Вместо этого редюсеры должны делать обновления, копируя существующее состояние и внося изменения в копию.
Редюсеры не должны выполнять никаких «побочных эффектов». Например, запуск таймера, выполнение HTTP-запроса, изменение значения вне функции или ее аргументов, генерация случайных чисел или строк и т. п.
Как выполнять побочные эффекты мы рассмотрим далее, пока что просто помните - редюсер должен быть чистой функцией. Получая аргументы, он должен вычислить следующее состояние и вернуть его. Никаких побочных эффектов. Никаких мутаций. Только вычисление новой версии состояния.

Обработка экшенов
Добавим в корневой редюсер код обработки всех остальных экшенов нашего приложения.

Удаление задачи
При удалении нам доступен идентификатор задачи в свойстве payload, поэтому используем метод Array.filter() для того, чтобы иммутабельно создать новый массив без этой задачи. Проверяем соответствует ли тип отправленного экшена строке "tasks/deleteTask" и возвращаем новый объект состояния.

src/redux/reducer.js
export const rootReducer = (state = initialState, action) => {
  switch (action.type) {
    case "tasks/addTask":
      return {
        ...state,
        tasks: [...state.tasks, action.payload],
      };
    case "tasks/deleteTask":
      return {
        ...state,
        tasks: state.tasks.filter(task => task.id !== action.payload),
      };
    default:
      return state;
  }
};

Переключение статуса
При переключении статуса нам доступен идентификатор задачи в свойстве payload, поэтому используем метод Array.map() для того, чтобы иммутабельно создать новый массив с измененным значением свойства completed у задачи с соответствующим идентификатором. Проверяем соответствует ли тип отправленного экшена строке "tasks/toggleCompleted" и возвращаем новый объект состояния.

src/redux/reducer.js
export const rootReducer = (state = initialState, action) => {
  switch (action.type) {
    case "tasks/addTask":
      return {
        ...state,
        tasks: [...state.tasks, action.payload],
      };
    case "tasks/deleteTask":
      return {
        ...state,
        tasks: state.tasks.filter(task => task.id !== action.payload),
      };
    case "tasks/toggleCompleted":
      return {
        ...state,
        tasks: state.tasks.map(task => {
          if (task.id !== action.payload) {
            return task;
          }
          return {
            ...task,
            completed: !task.completed,
          };
        }),
      };
    default:
      return state;
  }
};

Изменение фильтра
При изменении фильтра нам доступно новое значение фильтра payload, поэтому проверяем соответствует ли тип отправленного экшена строке "filters/setStatusFilter" и возвращаем новый объект состояния.

src/redux/reducer.js
export const rootReducer = (state = initialState, action) => {
  switch (action.type) {
    case "tasks/addTask":
      return {
        ...state,
        tasks: [...state.tasks, action.payload],
      };
    case "tasks/deleteTask":
      return {
        ...state,
        tasks: state.tasks.filter(task => task.id !== action.payload),
      };
    case "tasks/toggleCompleted":
      return {
        ...state,
        tasks: state.tasks.map(task => {
          if (task.id === action.payload) {
            return {
              ...task,
              completed: !task.completed,
            };
          }
          return task;
        }),
      };
    case "filters/setStatusFilter":
      return {
        ...state,
        filters: {
          ...state.filters,
          status: action.payload,
        },
      };
    default:
      return state;
  }
};

Мы добавили код обработки всего четырех экшенов, а код корневого редюсера уже становится громоздким. Если пытаться обработать все экшены приложения в одной функции-редюсере, код будет довольно трудным для понимания. Поэтому редюсеры обычно разделяются на несколько более мелких, чтобы упростить понимание и поддержку кода.

Композиция редюсеров
Обычно редюсеры разделяются основываясь на частях состояния Redux которые они обновляют. Разделим обработку экшенов задач и изменения фильтра на два независимых редюсера. Каждый редюсер будет отвечать только за свою часть состояния Redux, поэтому код обновления состояния будет значительно проще.

src/redux/reducer.js
const tasksInitialState = [
  { id: 0, text: "Learn HTML and CSS", completed: true },
  { id: 1, text: "Get good at JavaScript", completed: true },
  { id: 2, text: "Master React", completed: false },
  { id: 3, text: "Discover Redux", completed: false },
  { id: 4, text: "Build amazing apps", completed: false },
];
// Отвечает только за обновление свойства tasks
// Теперь значением параметра state будет массив задач
const tasksReducer = (state = tasksInitialState, action) => {
  switch (action.type) {
    case "tasks/addTask":
      return [...state, action.payload];
    case "tasks/deleteTask":
      return state.filter(task => task.id !== action.payload);
    case "tasks/toggleCompleted":
      return state.map(task => {
        if (task.id !== action.payload) {
          return task;
        }
        return { ...task, completed: !task.completed };
      });
    default:
      return state;
  }
};
const filtersInitialState = {
  status: statusFilters.all,
};
// Отвечает только за обновление свойства filters
// Теперь значением параметра state будет объект фильтров
const filtersReducer = (state = filtersInitialState, action) => {
  switch (action.type) {
    case "filters/setStatusFilter":
      return {
        ...state,
        status: action.payload,
      };
    default:
      return state;
  }
};

Теперь у нас есть два отдельных редюсера, но при создании стора необходимо передать один корневой редюсер, отвечающий за все состояние Redux. Мы можем написать корневой редюсер так, чтобы он просто вызывал два других редюсера и передавал им необходимую часть состояния и экшен. Это и есть композиция редюсеров.

src/redux/reducer.js
// Код редюсеров tasksReducer и filtersReducer
export const rootReducer = (state = {}, action) => {
  // Возвращаем объект состояния
  return {
    // Обоим редюсерам передаем только часть состояния за которую они отвечают
    tasks: tasksReducer(state.tasks, action),
    filters: filtersReducer(state.filters, action),
  };
};

Чтобы не создавать корневой редюсер вручную, в библиотеке Redux есть функция combineReducers, которая делает тоже самое, но более кратко.

src/redux/reducer.js
// Импортируем функцию композиции редюсеров
import { combineReducers } from "redux";
// Код редюсеров tasksReducer и filtersReducer
export const rootReducer = combineReducers({
  tasks: tasksReducer,
  filters: filtersReducer,
});

Планировщик задач
Разберите полный живой пример нашего приложения.

