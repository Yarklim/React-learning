Маршрутизация
Отличающее преимущество веб-приложения от десктопного это наличие URL при переходе по которому пользователь оказывается в определенной части приложения. Так можно сохранить закладку или передать ссылку другому пользователю, при этом ему будет отображен один и тот же интерфейс (за исключением приватных данных).

В ПЕРВУЮ ОЧЕРЕДЬ
Маршрутизация это не побочный эффект при написании приложения, наоборот, структуру навигации и набор страниц необходимо продумывать в первую очередь.

Структура URL-строки
Аналогией URL-строки может быть адрес по которому вы проживаете: улица, дом, квартира. У каждого состояния интерфейса должен быть свой адрес, свой URL. То, что видит пользователь, состояние интерфейса, должно быть описано в URL.

url-string
Разберем из каких частей может состоять любой URL.

https:// - протокол
mysite.com/ - хост
books/e3q76gm9lzk - путь, то где мы находимся в приложении
e3q76gm9lzk - url-параметр. Параметры бывают динамическими или статическими
? - символ начала строки запроса
?category=adventure&status=unread - строка запроса
category=adventure - пара параметр=значение
& - символ "И", разделяет параметры строки запроса
#comments - якорь (хеш), определяет положение на странице
История навигации
История навигации описывает как мы переходим по маршрутам (ссылкам) приложения в текущей вкладке браузера и как эти переходы хранятся и обрабатываются. Представьте стопку листов, каждый раз когда мы переходим по ссылке, на верх стопки добавляется еще один лист с информацией. Это называется стек истории. Используя свойства и методы HTML5 History API мы можем переходить назад и вперёд по истории пользователя и манипулировать её содержимым.

HTML5 HISTORY API
Если вы хотите глубже понять React Router, после знакомства с основными концепцияи рекомендуем вернуться и разобрать статью A Little Bit of History.

Маршрутизация в React
В React нет встроенного модуля маршрутизации, поэтому используется React Router - библиотека маршрутизации для React. Точно так же, как React предоставляет нам набор примитивов для создания пользовательского интерфейса и работы с состоянием, React Router предоставляет набор компонентов и хуков для создания маршрутизации, управления историей навигации пользователя и отображения различных компонетов в зависимости от текущего значения URL в адресной строке браузера.

npm install react-router-dom

Компонент BrowserRouter
Командный центр управления маршрутизацией который скрывает в себе всю логику взаимодействия с историей браузера. Создает маршуртизатор и объект истории навигации, чтобы синхронизировать интерфейс с URL-адресом. Используя React контекст передает информацию о текущем состоянии истории навигации всем потомкам. Все что необходимо сделать, это обернуть компонентом BrowserRouter все приложение.

src/index.js
import { BrowserRouter } from "react-router-dom";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

Далее рассмотри как описывать маршруты приложения.

Компоненты Route и Routes
Компонент Route позволяет связать определенный URL с некоторым компонентом. Например, если мы хотим отображать компонент About когда пользователь переходит по пути /about, необходимо будет описать такой маршрут.

<Route path="/about" element={<About />} />

Значением пропса element может быть любой валидный JSX, но на практике используют только компоненты.

КАК ЭТО РАБОТАЕТ
Компонент Route всегда что-то рендерит. То, что указано в пропсе element если его path совпадает с текущим зачением сегмента pathname в адресной строке браузера, либо null, если не совпадает.

Маршрутов может быть произвольное количество, как минимум по одному на каждую страницу приложения. Допустим мы создаем приложение магазина одежды, поэтому опишем маршруты трех страниц.

src/components/App.jsx
import { Routes, Route } from "react-router-dom";
import Home from "path/to/pages/Home";
import About from "path/to/pages/About";
import Products from "path/to/pages/Products";

export const App = () => {
  return (
    <div>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/products" element={<Products />} />
      </Routes>
    </div>
  );
};

Группу маршрутов обязательно должен оборачивать компонент Routes, даже если маршрут всего один. То есть Route не может использоваться вне Routes. Этот компонент выполняет логику подбора наиболее подходящего Route для текущего значения URL в адресной строке браузера.

КОМПОНЕНТЫ СТРАНИЦ
Вы уже знаете что конвенция структуры файлов приложения подразумевает хранение всех компонентов в папке src/components. Компонент страницы это самый обычный React-компонент, который включает в себя разметку целой страницы вашего приложения. Для удобства и структурированности такие компоненты хранятся отдельно от всех, в папке src/pages.

Страница ошибки навигации
Что будет если пользователь перейдет по ссылке /non-existing-route или любой другой, которой не существует в нашем приложении? Он увидит пустую вкладку браузера, без какого либо контента, так как ни один из описанных нами Route не подойдет. Для этого в самый конец списка маршрутов добавим еще один Route, который будет совпадать с любым URL, но он будет выбран только в том случае, если ни один другой маршрут не подойдет.

src/components/App.jsx
import { Routes, Route } from "react-router-dom";
import Home from "path/to/pages/Home";
import About from "path/to/pages/About";
import Products from "path/to/pages/Products";
import NotFound from "path/to/pages/NotFound";

const App = () => {
  return (
    <div>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/products" element={<Products />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </div>
  );
};

Символ * в пропсе path буквально указывает на то, что этот маршрут может совпадать с любым значеним URL. Поэтому если ни один предыдущий Route не подойдет, последний уж точно отобразит пользователю страницу с каким-то сообщением о том, что маршрута по которому он перешел не существует.

Компоненты Link и NavLink
Теперь рассмотрим как создавать ссылки на различные страницы нашего приложения. Для создания навигации нельзя использовать обычный тег <a href="/about">. При клике, вместо того чтобы изменить URL на текущей странице, и позволить маршрутизатору выполнить навигацию на стороне клиента, браузер перезагрузит страницу.

Для создания ссылок используются компоненты Link и NavLink. Они рендерят тег <a>, но стандартное поведение ссылки изменено так, что при клике просто обновляется URL в адресной строке браузера, без перезагрузки страницы.

<nav>
  <Link to="/">Home</Link>
  <Link to="/about">About</Link>
  <Link to="/products">Products</Link>
</nav>

Компонент NavLink отличается только тем, что может иметь дополнительные стили, если текущий URL совпадает со значением пропcа to. По умолчанию элементу активной ссылки добавляется класс active. Это можно использовать для её стилизации.

src/components/App.jsx
import { Routes, Route, NavLink } from "react-router-dom";
import styled from "styled-components";
import Home from "path/to/pages/Home";
import About from "path/to/pages/About";
import Products from "path/to/pages/Products";

const StyledLink = styled(NavLink)`
  color: black;

  &.active {
    color: orange;
  }
`;

export const App = () => {
  return (
    <div>
      <nav>
        <StyledLink to="/" end>
          Home
        </StyledLink>
        <StyledLink to="/about">About</StyledLink>
        <StyledLink to="/products">Products</StyledLink>
      </nav>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/products" element={<Products />} />
      </Routes>
    </div>
  );
};

Разберите код живого примера приложения нашего магазина, в котором используется весь материал который мы с вами разобрали до этого момента.

URL-параметры
Динамические параметры похожи на параметры функции - у них всегда одно название, но могут быть разные значения. Они позволяют объявить шаблон адреса, части которого могут иметь произвольное значение. Например, не имеет смысла определять отдельный маршрут для каждого поста в блоге, их могут быть тысячи. По структуре контента такие страницы будут идентичны, а отличаться будет только название, изображение, автор, текст и т. п. Вместо того чтобы определять маршрут для каждой статьи, мы можем объявить один маршрут с динамическим параметром по которому будем определять какой пост необходимо отображать именно сейчас. Для того чтобы указать, что какая-то часть адреса это URL-параметр, используется двоеточие (:) перед именем параметра.

<Route path="/blog/:postId" element={<BlogPost />} />

Каждый раз, когда пользователь будет посещать адрес соответствующий шаблону /blog/:postId, например /blog/react-fundamentals или /blog/top-5-css-tricks, ему будет отображаться страница этого поста.

ИМЯ ПАРАМЕТРА
Имя URL-параметра может быть произвольным, но оно имеет значение и должно быть понятным и описательным. Далее мы рассмотрим как получать значение URL-параметра. Спойлер - по его имени.

Добавим в наше приложение маршрут страницы одного продукта c адресом /products/:productId. Это отдельная страница, никак не привязанная к /products - странице отображения всех продуктов.

src/components/App.jsx
import { Routes, Route, Link } from "react-router-dom";
import Home from "path/to/pages/Home";
import About from "path/to/pages/About";
import Products from "path/to/pages/Products";
import NotFound from "path/to/pages/NotFound";
import ProductDetails from "path/to/pages/ProductDetails";

export const App = () => {
  return (
    <div>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/products">Products</Link>
      </nav>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/products" element={<Products />} />
        <Route path="/products/:productId" element={<ProductDetails />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </div>
  );
};

УНИКАЛЬНОСТЬ ЗНАЧЕНИЯ
Значение URL-параметра должно быть уникальным внутри коллекции, поэтому чаще всего используют идентификаторы объектов, которые устанавливает база данных (числа или строки). Поэтому адрес может выглядеть, например, как /products/1, /proudcts/2 и так далее.

Хук useParams
Возвращает объект со всеми динамическими параметрами которые есть в текущем URL. Имя параметра будет именем свойства в объекте, а его текущее значение в адресе - значением свойства. Например, если объявлен следующий маршрут /books/:genreId/:authorName, и пользователь находится по адресу /books/adventure/herman-melville.

const { genreId, authorName } = useParams();
console.log(genreId, authorName); // adventure, herman-melville

Для того чтобы получить значение динамической части URL, в нашем случае идентификатор продукта, используем хук useParams в компоненте страницы продукта.

src/pages/ProductDetails.jsx
import { useParams } from "react-router-dom";

const ProductDetails = () => {
  const { productId } = useParams();
  return <div>Now showing product with id - {productId}</div>;
};

ЧТО ДАЛЬШЕ?
Имея значение параметра можно, например, сделать запрос на бекенд и получить полную информацию о продукте по его идентификатору, после чего отрендерить разметку страницы.

Разберите код живого примера приложения нашего магазина, в котором используется весь материал который мы с вами разобрали до этого момента.

Вложенные маршруты
Вложенные маршруты позволяют описывать логику «подстраниц», то есть какой-то URL по которому кроме родительского компонента целой страницы будет отображаться еще какой-то дочерний, вложенный компонент.

Например, нам необходимо чтобы на /about/mission, /about/team и /about/reviews кроме контента страницы «О нас» отображалась еще какая-то дополнительная, более специфическая информация. Пусть это будет несколько различных компонентов: статья о миссии нашей компании, галерея с информацией о сотрудниках и отзывы пользователей.

// ❌ Неправильно
<Route path="/about" element={<About />} />
<Route path="/about/mission" element={<Mission />} />
<Route path="/about/team" element={<Team />} />
<Route path="/about/reviews" element={<Reviews />} />

Если описать маршруты так, то получим четыре независимые страницы. На /about будет отображаться только страница информации, а например на about/team галерея сотрудников, это не то что нам нужно. Используем синтаксис объявления вложенного маршрута, компонент которого будет отображаться внутри родительской страницы.

// ✅ Правильно
<Route path="/about" element={<About />}>
  <Route path="mission" element={<Mission />} />
  <Route path="team" element={<Team />} />
  <Route path="reviews" element={<Reviews />} />
</Route>

Обратите внимание на несколько особенностей:

Мы декларативно вложили дочерние маршруты внутрь родительского Route. Именно такой синтаксис указывает на вложенный маршрут, компонент которого будет отображаться где-то внутри родительского компонента.
Значение пропса path у вложенного маршрута указывается относительно родительского, именно поэтому мы передали значение path="mission", а не полный путь path="/about/mission".
Относительные пути записываются без ведущего символа /, то есть path="mission", а не path="/mission". Если добавить слеш, то мы наоборот создадим отдельный маршрут /mission и сломаем логику маршрутизации.
Полная конфигурация маршрутов нашего приложения будет выглядеть так.

src/components/App.jsx
import { Routes, Route, Link } from "react-router-dom";
import Home from "path/to/pages/Home";
import About from "path/to/pages/About";
import Products from "path/to/pages/Products";
import NotFound from "path/to/pages/NotFound";
import ProductDetails from "path/to/pages/ProductDetails";
import Mission from "path/to/components/Mission";
import Team from "path/to/components/Team";
import Reviews from "path/to/components/Reviews";

export const App = () => {
  return (
    <div>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/products">Products</Link>
      </nav>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />}>
          <Route path="mission" element={<Mission />} />
          <Route path="team" element={<Team />} />
          <Route path="reviews" element={<Reviews />} />
        </Route>
        <Route path="/products" element={<Products />} />
        <Route path="/products/:productId" element={<ProductDetails />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </div>
  );
};

Последнее что обязательно необходимо сделать, это указать где именно в компоненте родительского маршрута About мы хотим рендерить дочерние маршруты. Для этого в React Router есть компонент Outlet.

src/pages/About.jsx
import { Link, Outlet } from "react-router-dom";

export const About = () => {
  return (
    <div>
      <h1>About page</h1>
      <ul>
        <li>
          <Link to="mission">Read about our mission</Link>
        </li>
        <li>
          <Link to="team">Get to know the team</Link>
        </li>
        <li>
          <Link to="reviews">Go through the reviews</Link>
        </li>
      </ul>
      <Outlet />
    </div>
  );
};

Если текущий URL в адресной строке браузера совпадет со значением пропса path вложенного маршрута, Outlet отрендерит его компонент, в противном случае, он рендерит null и не влияет на разметку родительского компонента.

ОТНОСИТЕЛЬНЫЕ ССЫЛКИ
Обратите внимание на значение пропса to компонента Link. Также как и path вложенного маршрута, значение пропса to вложенных ссылок указывается относительно текущего URL. Компонент About рендерится на адрес /about, поэтому ссылка с to="mission" будет вести на /about/mission. Если необходимо сделать ссылку на другую страницу, тогда указывайте путь полностью, например to="/products".

Разберите код дополненного примера приложения магазина, в котором используется весь материал который мы с вами разобрали до этого момента.

Индексные маршруты
Разобравшись с вложенными маршрутами мы можем рассмотреть приём «shared layout», который заключается в том, что какая-то общая HTML-разметка и стили всего или части страниц приложения выносятся в отдельный компонент, вместо того чтобы дублироваться на каждой странице. В нашем приложении магазина это хедер с логотипом и главной навигацией, а также контейнер ограничивающий ширину контента страниц.

src/components/App.jsx
// Imports

export const App = () => {
  return (
    <Container>
      <Header>
        <Logo>
          <span role="img" aria-label="computer icon">
            💻
          </span>{" "}
          GoMerch Store
        </Logo>
        <nav>
          <Link to="/">Home</Link>
          <Link to="/about">About</Link>
          <Link to="/products">Products</Link>
        </nav>
      </Header>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />}>
          <Route path="mission" element={<Mission />} />
          <Route path="team" element={<Team />} />
          <Route path="reviews" element={<Reviews />} />
        </Route>
        <Route path="/products" element={<Products />} />
        <Route path="/products/:productId" element={<ProductDetails />} />
      </Routes>
    </Container>
  );
};

Вынесем эту разметку и её стили в отдельный компонент SharedLayout. Обратите внимание на использование и местоположение Outlet - в это место будет рендерится разметка компонентов страниц.

src/components/SharedLayout.jsx
// Imports
import { Outlet } from "react-router-dom";

export const SharedLayout = () => {
  return (
    <Container>
      <Header>
        <Logo>
          <span role="img" aria-label="computer icon">
            💻
          </span>{" "}
          GoMerch Store
        </Logo>
        <nav>
          <Link to="/">Home</Link>
          <Link to="/about">About</Link>
          <Link to="/products">Products</Link>
        </nav>
      </Header>
      <Outlet />
    </Container>
  );
};

Далее используем этот компонент в App так чтобы он рендерился на любой маршрут. Для этого будем рендерить его на /, а все остальные маршруты делаем вложенными в него, поэтому изменим path всех вложенных маршрутов относительно родительского.

src/components/App.jsx
// Imports
import { SharedLayout } from "path/to/components/SharedLayout";

export const App = () => {
  return (
    <Routes>
      <Route path="/" element={<SharedLayout />}>
        <Route path="about" element={<About />}>
          <Route path="mission" element={<Mission />} />
          <Route path="team" element={<Team />} />
          <Route path="reviews" element={<Reviews />} />
        </Route>
        <Route path="products" element={<Products />} />
        <Route path="products/:productId" element={<ProductDetails />} />
      </Route>
    </Routes>
  );
};

У вас может возникнуть справедливый вопрос куда пропал компонент Home который ранее рендерился на path="/". Проблема в том, что сейчас на /about рендерится SharedLayout и About, а на / только SharedLayout. Для того чтобы отрендерить компонент Home на тот же маршрут на который рендерится его родитель, необходимо сделать «индексный маршрут».

src/components/App.jsx
// Imports
import { SharedLayout } from "path/to/components/SharedLayout";

export const App = () => {
  return (
    <Routes>
      <Route path="/" element={<SharedLayout />}>
        <Route index element={<Home />} />
        <Route path="about" element={<About />}>
          <Route path="mission" element={<Mission />} />
          <Route path="team" element={<Team />} />
          <Route path="reviews" element={<Reviews />} />
        </Route>
        <Route path="products" element={<Products />} />
        <Route path="products/:productId" element={<ProductDetails />} />
      </Route>
    </Routes>
  );
};

КАК ЭТО РАБОТАЕТ
Индексным может быть только вложенный маршрут. В его Route не указывается пропс path, потому что он совпадает со значением path родителя. Вместо этого передается специальный пропс index, который указывает React Router что маршрут индексный и должен быть отрендерен на тот же адрес что и его родитель.


Индексных маршрутов может быть сколько угодно, все зависит от задачи. Например, если бы у нас в приложении были страницы панели администратора, на которых совсем другие общие компоненты интерфейса, то структуру маршрутов можно было бы спроектировать следующим образом.

<Routes>
  <Route path="/" element={<SharedLayout />}>
    <Route index element={<Home />} />
    <Route path="about" element={<About />}>
      <Route path="mission" element={<Mission />} />
      <Route path="team" element={<Team />} />
      <Route path="reviews" element={<Reviews />} />
    </Route>
    <Route path="products" element={<Products />} />
    <Route path="products/:productId" element={<ProductDetails />} />
  </Route>
  <Route path="/admin" element={<AdminLayout />}>
    <Route index element={<Dashboard />} />
    <Route path="sales" element={<Sales />} />
    <Route path="customers" element={<Customers />} />
  </Route>
</Routes>

Программная навигация
React Router позволяет выполнить навигацию не только при клике по Link, но и по определенному действию пользователя, событию или эффекту. Например, при нажатии на кнопку, после отправки формы, по результату HTTP-запроса и тому подобное. Для примера используем процесс логина пользователя в приложение. После отправки формы на странице логина мы выполняем навигацию на страницу профиля пользователя, но только если HTTP-запрос был успешным.

Первый способ это хук useNavigate. Он предоставляет нам функцию navigate которой при вызове передаем путь куда необходимо выполнить навигацию. Этот способ императивный, но более гибкий и требует меньше кода.

src/pages/Login.jsx
import { useNavigate } from "react-router-dom";

export const Login = () => {
  const navigate = useNavigate();

  const handleSubmit = async values => {
    const response = await FakeAPI.login(values);
    if (response.success) {
      navigate("/profile", { replace: true });
    }
  };

  return (
    <div>
      <h1>Login page</h1>
      <LoginForm onSubmit={handleSubmit} />
    </div>
  );
};

ОБЪЕКТ ПАРАМЕТРОВ
Обратите внимание на второй, необязаельный аргумент функции navigate - это объект параметров. Свойство replace, по умолчанию false, контролирует как будет добавлена новая запись на стек истории. Вернемся к аналогии со стопкой бумаг. По умолчанию новый лист будет добавлен на верх стопки, что никак не повлияет на остальные листы. Если указать значение true, то новый лист подменит собой самый верхний. Это используется довольно редко, например при логине, чтобы пользователь не смог вернуться кнопкой «назад» на страницу логина после входа, ведь он уже в системе и делать ему там больше нечего.

Второй способ это компонент Navigate - обертка над хуком useNavigate. Он выполняет навигацию в момент рендера. Путь для навигации и необязательные параметры передаются отдельными пропсами. Такой способ более декларативный, но менее гибкий и требует больше кода.

src/pages/Login.jsx
import { Navigate, useState } from "react-router-dom";

export const Login = () => {
  const [isLoginSuccess, setIsLoginSuccess] = useState(false);

  const handleSubmit = async values => {
    const response = await FakeAPI.login(values);
    setIsLoginSuccess(response.success);
  };

  if (isLoginSuccess) {
    return <Navigate to="/profile" replace />;
  }

  return (
    <div>
      <h1>Login page</h1>
      <LoginForm onSubmit={handleSubmit} />
    </div>
  );
};

ЧТО ЛУЧШЕ?
Какой способ использовать зависит только от ваших предпочтений и требований поставленной задачи. В одном случае вам будет удобно использовать декларативный Navigate, в другом - императивный useNavigate.

Строка запроса
Строка запроса и её параметры это фундаментальный аспект веба, поскольку она позволяет передавать состояние приложения через URL-адрес. Строка запроса добавляется к основному URL, начинается символом ? и содержит один или более параметров в формате «ключ-значение» разделенных символом &.

https://gomerch.it/products?name=hoodie&color=orange&maxPrice=500

Такая строка запроса содержит три параметра и их значения: название продукта, цвет и максимальную цену. При переходе по этому URL, пользователь увидит подходящий, отфильтрованный список продуктов.

Рассмотрим работу со строкой запроса и её параметрами на примере каталога продуктов, по которому пользователь может выполнить поиск по названию и видеть отфильтрованный список совпадений.

Gamestore app UI
Использование локального состояния через хук useState хорошо для одного пользователя, но плохо для совместной работы с другими пользователями. Если состояние приложения находится в URL, им можно поделиться с другими пользователями. Например, когда пользователь ищет продукты, значение поиска добавляется к URL как параметр строки запроса (/products?name=hoodie). Другой пользователь, получивший эту ссылку, увидит тот же отфильтрованный список продуктов на своей странице, потому что все данные, необходимые приложению для правильного отображения интерфейса, находятся прямо в URL.

Извлечение параметров
Для чтения и изменения строки запроса в React Router есть хук useSearchParams, который представляет собой небольшую обертку над встроенным в браузер классом URLSearchParams.

const [searchParams, setSearchParams] = useSearchParams();

Он возвращает массив из двух значений: объект параметров строки запроса (экземпляр URLSearchParams) для текущего URL и функцию обновления строки запроса. Для получения значений параметров есть метод URLSearchParams.get(key), который ожидает имя параметра и возвращает его значение или null если в строке запроса нет такого параметра.

src/pages/Products.jsx
import { useSearchParams } from "react-router-dom";

const Products = () => {
  const [searchParams] = useSearchParams();
  const name = searchParams.get("name");
  const color = searchParams.get("color");
  const maxPrice = searchParams.get("maxPrice");

  return (
    <div>
      <p>Name: {name}</p>
      <p>Color: {color}</p>
      <p>Maximum price: {maxPrice}</p>
    </div>
  );
};

Тип значений
Метод get() всегда вернет строку не зависимо от значения параметра которое указано в строке запроса. Например, для такой строки запроса ?name=hoodie&maxPrice=500&inStock=true мы получим следующие значения параметров.

const [searchParams] = useSearchParams();

const name = searchParams.get("name");
console.log(name, typeof name); // "hoodie", string

const maxPrice = searchParams.get("maxPrice");
console.log(maxPrice, typeof maxPrice); // "500", string

const inStock = searchParams.get("inStock");
console.log(inStock, typeof inStock); // "true", string

ПРИВЕДЕНИЕ ТИПОВ
Если параметры это числа или були, то для получения значения правильного типа необходимо выполнить приведение типов. Это можно сделать встроенными классами Number(value) и Boolean(value).

Параметры как объект
Если строка запроса содержит несколько параметров, то постоянно использовать метод get() может быть неудобно. Вот простой способ преобразовать экземпляр класса URLSearchParams в обычный объект со свойствами.

const [searchParams] = useSearchParams();
const params = useMemo(
  () => Object.fromEntries([...searchParams]),
  [searchParams]
);
const { name, maxPrice, inStock } = params;

МЕМОИЗАЦИЯ
Мемоизируем операцию преобразования объекта параметров, чтобы получать ссылку на новый объект только если изменятся параметры строки запроса, а не при каждом рендере компонента.

Изменение строки запроса
Для изменения параметров используем функцию которую useSearchParams возвращает вторым элементом массива. Ей необходимо передать объект новых параметров, который полностью заменит текущую строку запроса.

import { useSearchParams } from "react-router-dom";

export const Products = () => {
  const [searchParams, setSearchParams] = useSearchParams();
  const name = searchParams.get("name");

  return (
    <div>
      <h1>Products</h1>
      <input
        type="text"
        value={name}
        onChange={e => setSearchParams({ name: e.target.value })}
      />
    </div>
  );
};

Разберите полный код примера страницы всех продуктов (Products), в котором реализовано изменение строки запроса и фильтрация списка. Обратите внимание на то как сделано удаление параметра name, если значение поля ввода это пустая строка.


Отслеживание изменений
Если меняется строка запроса, хук useSearchParams возвращает новое значение параметров и компонент обновляется, поэтому можно среагировать на это и запустить эффект.

const App = () => {
  const [user, setUser] = useState(null);
  const [searchParams, setSearchParams] = useSearchParams();
  const username = searchParams.get("username");

  useEffect(() => {
    // Тут выполняем асинхронную операцию,
    // например HTTP-запрос за информацией о пользователе
    if (username === "") return;

    async function fetchUser() {
      const user = await FakeAPI.getUser(username);
      setUser(user);
    }

    fetchUser();
  }, [username]);

  const handleSubmit = e => {
    e.preventDefault();
    const form = e.currentTarget;
    setSearchParams({ username: form.elements.username.value });
    form.reset();
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <input type="text" name="username" />
        <button type="submit">Search</button>
      </form>
      {user && <UserInfo user={user} />}
    </>
  );
};

Объект местоположения
Каждая запись в стеке истории навигации описана объектом местоположения (location) со стандартным набором свойств, которые хранят полную информацию о URL. Когда пользователь нажимает на ссылки и перемещается по приложению, текущее местоположение меняется и добавляется новая запись истории.

{
  pathname: string;
  search: string;
  hash: string;
  state: any;
  key: string;
}

pathname - строка, содержащая часть URL от начального / и до символа ?.
search - содержит всю строку запроса. Если параметры отсутствуют, значением будет пустая строка.
hash - строка, содержащая часть URL от конца строки запроса и символа #, за которым следует идентификатор фрагмента URL-адреса. Если идентификатор фрагмента отсутствует, значением будет пустая строка.
state - произвольное значение, которое содержит дополнительную информацию, связанную с местоположением, но не отображается в URL-адресе. Задается разработчиком. Используется для передачи данных между маршрутами.
key - уникальная строка идентификатор, связанная с этим местоположением. Служебное свойство, значение которого задается автоматически для каждой новой записи в истории навигации.
Например, для такого URL объект местоположения будет выглядеть следующим образом.

// https://gomerch.it/products?name=hoodie&color=orange&maxPrice=500#agreement

{
  "pathname": "/products",
  "search": "?name=hoodie&color=orange&maxPrice=500",
  "hash": "#agreement",
  "state": null,
  "key": "random-browser-generated-id"
}

Хук useLocation
Возвращает объект местоположения, представляющий текущий URL, каждый раз когда мы переходим по новому маршруту или обновляем часть текущего URL. Одним из применений может быть задача, где необходимо выполнить какой-то эффект при изменении текущего местоположения. Например, отправить данные на сервис аналитики.

src/component/App.jsx
import { useEffect } from "react";
import { useLocation } from "react-router-dom";
import Analytics from "path/to/analytics-service";

const App = () => {
  const location = useLocation();

  useEffect(() => {
    Analytics.send(location);
  }, [location]);

  return <div>...</div>;
};

Свойство location.state
Представьте следующий сценарий в нашем приложении магазина. Пользователь находится на странице списка продуктов и выполнил поиск по названию, пусть текущий URL будет /products?name=hoodie. После этого он кликает по карточке продукта и переходит на страницу расширенной информации о продукте, пусть текущий URL будет /products/h-1.

Нам поставлена задача добавить на страницу продукта кнопку «Назад», при клике по которой выполнится навигация на страницу всех продуктов, при этом должно сохраниться состояние строки запроса. То есть, при клике, пользователя необходимо направить не на /products, а в нашем случае на /products?name=hoodie - тот URL с которого была выполнена навигация на страницу продукта.

{
  pathname: string;
  search: string;
  hash: string;
  state: any;
  key: string;
}

Свойство state объекта местоположения позволяет передавать произвольные данные при навигации от одного маршрута к другому. Для этого используем пропс state компонента Link и передадим объект со свойством from - откуда пришел пользователь. Значение пропса state не имеет предопределенной структуры и может быть произвольным, на усмотрение разработчика.

src/pages/Products.jsx
const Products = () => {
  return (
    <Link to="/products/h-1" state={{ from: "/dashboard?name=hoodie" }}>
      Navigate to product h-1
    </Link>
  );
};

Значение пропса state будет доступно на объекте местоположения маршрута куда была выполнена навигация. Все что необходимо сделать, это использовать хук useLocation, получить обьект location и обратиться к его свойству state.

src/pages/ProductDetails.jsx
const ProductDetails = () => {
  const location = useLocation();
  console.log(location.state); // { from: "/dashboard?name=hoodie" }

  return <Link to={location.state.from}>Back to products</Link>;
};

На самом деле не нужно вычислять текущий URL для формирования значения свойста from. Объект location описывает все части URL текущего маршрута, поэтому можно передать его в пропс state.

src/pages/Products.jsx
const Products = () => {
  const location = useLocation();

  return (
    <Link to="/product/h-1" state={{ from: location }}>
      Navigate to product h-1
    </Link>
  );
};

В свойстве location.state будет ссылка на объект location маршрута с которого произошла навигация. Пропсу to компонента Link можно передавать не только строку описывающую href будущей ссылки, но и целый объект location.

src/pages/ProductDetails.jsx
const ProductDetails = () => {
  const location = useLocation();
  console.log(location.state);

  // /products -> products/h-1
  // { from: { pathname: "/products", search: "" } }

  // /products?name=hoodie -> products/h-1
  // { from: { pathname: "/products", search: "?name=hoodie" } }

  return <Link to={location.state.from}>Back to products</Link>;
};

Последнее что необходимо учесть это случай, когда пользователь перешел по сохраненной ранее ссылке одного продукта в новой вкладке браузера, а не со страницы всех продуктов. В таком случае значение location.state будет null и при обращении к свойству location.state.from приложение упадет с ошибкой. Поэтому необходимо позаботиться о значении по умолчанию для пропса to.

src/pages/ProductDetails.jsx
const ProductDetails = () => {
  const location = useLocation();
  const backLinkHref = location.state?.from ?? "/products";

  return <Link to={backLinkHref}>Back to products</Link>;
};

Разберите полный код примера магазина одежды с добавленным функционалом возврата со страницы одного продукта. Изменился код компонентов ProductList и ProductDetails.

Разделение кода
По умолчанию все зависимости проекта объединяются в один файл. Чем больше кода, тем медленнее он будет загружаться, парситься и исполняться в браузере пользователя. На слабых компьютерах или телефонах, с плохим подключением к Интернет, это могут быть десятки секунд.

При разработке на локальном сервере (localhost) все файлы раздаются с нашего компьютера. В этом случае скорость подключения к Интернету не имеет значения, и поэтому файлы проекта загружаются очень быстро. Однако в продакшене загрузка больших файлов может стать проблемой, потому что не везде есть высокоскоростной Интернет и мощные компьютеры.

Решение проблемы очевидно - разбить проект на более мелкие файлы и загружать их только по необходимости. В этом и заключается концепция разделения кода. Если пользователь заходит на страницу логина, не нужно загружать весь код приложения, будет достаточно части отвечающей за рендер компонентов только этой страницы.

Code splitting
CREATE REACT APP
Разделение кода на несколько файлов это задача сборщика проекта, например Webpack, а не фронтенд фреймворка. Create React App внутренне использует Webpack как сборщик и поддерживает разделение кода без дополнительной настройки.

Код приложения необходимо разделять по маршрутам и загружать по необходимости. Этого достаточно для большинства приложений. Переходим на новую страницу - загружается необходимый код для отображения её компонентов. Такой подход называется разделение кода на основе маршрутов (route-centric).

Route-centric code splitting
Интерфейсы могут быть очень громоздкими. Если пойти дальше, то можно оптимизировать загрузку отдельных, очень больших компонентов страницы, которые не нужны до определенного действия пользователя. Например, компонент модального окна в котором используется большая библиотека текстового редактора. Такой подход называется разделение кода на основе компонентов (component-centric).

Component-centric code splitting
ЧТО ИСПОЛЬЗОВАТЬ?
Разработчик принимает решение как, что и где разделять. Тем не менее вот несколько лучших практик.

Разделение кода на основе маршрутов обязательно в любом приложении.
Разделение кода на основе компонентов стоит делать только в больших, сложных интерфейсах с сотнями компонентов и большими библиотеками.
Чрезмерное разделение кода тоже не лучшая идея. HTTP-запрос за файлом может быть дольше чем добавленный вес к первой загрузке.
React.lazy() и React.Suspense
Вы уже знаете что ES модули статичны, то есть импорты и экспорты выполняются во время компиляции, а не во время выполнения кода. Импорты должны быть объявлены в верхней части файла, иначе будет ошибка компиляции. Это означает, что вы не можете импортировать зависимость динамически на основе какого-то условия.

Без разделения кода
import MyComponent from "path/to/MyComponent";

const App = () => {
  return (
    <Routes>
      <Route path="/some-path" element={<MyComponent />} />
      {/* Другие маршруты */}
    </Routes>
  );
};

В спецификации ES2020 появилась возможность динамического импорта модуля. Разница в том, что вместо обычного статического import используется функция import(), которая возвращает промис, значением которого будет файл модуля.

import("path/to/MyComponent").then(module => console.log(module));

React предоставляет API для того, чтобы указать какой код необходимо выделить в отдельный файл, а потом загружать и рендерить только при необходимости. Функция React.lazy() отвечает за асинхронную загрузку компонента, а Suspense приостанавливает его отображение до завершения загрузки.

С разделением кода
import { lazy, Suspense } from "react";

const MyComponent = lazy(() => import("path/to/MyComponent"));

const App = () => {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/some-path" element={<MyComponent />} />
        {/* Другие маршруты */}
      </Routes>
    </Suspense>
  );
};

Метод lazy() ожидает функцию-згарузчик, которая возвращает результат динамического импорта - промис, значением которого будет дефолтный экспорт модуля (компонент). Если во время рендера компонент MyComponent еще не загружен, необходимо показать заглушку. Для этого используется компонент Suspense. Проп fallback принимает любой React-элемент или компонент. Suspense можно поместить в любом месте над асинхронным компонентом или группой компонентов.

ДИНАМИЧЕСКИЙ ИМПОРТ
Обратите внимание на отсутствие статического импорта MyComponent в последнем примере. Вместо этого используется функция import(). Если оставить статический импорт, то Webpack не выполнить разделение кода и добавит весь код MyComponent в основной JavaScript файл проекта.

Suspense и прием «shared layout»
Если вы используете прием «shared layout», то нужно разместить Suspense непосредственно внутри компонента SharedLayout. В противном случае, при загрузке каждой страницы, будут пропадать и повторно рендериться компоненты общей части страниц, например хедер и навигация.

// src/components/App.jsx
import { lazy } from "react";

const MyComponent = lazy(() => import("path/to/MyComponent"));

const App = () => {
  return (
    <Routes>
      <Route path="/" element={<SharedLayout />}>
        <Route path="some-path" element={<MyComponent />} />
        {/* Другие маршруты */}
      </Route>
    </Routes>
  );
};

// src/components/SharedLayout.jsx
import { Suspense } from "react";
import { Outlet } from "react-router-dom";

const SharedLayout = () => {
  return (
    <Container>
      <AppBar>
        <Navigation />
        <UserMenu />
      </AppBar>

      <Suspense fallback={<div>Loading...</div>}>
        <Outlet />
      </Suspense>
    </Container>
  );
};

Разберите полный код приложения магазина с разделением кода на основе маршрутов. Изменился код компонентов App, SharedLayout и About, а все компоненты страниц стали дефолтными экспортами.


ВЛОЖЕННЫЕ МАРШРУТЫ И SUSPENSE
Обратите внимание на использование компонента Suspense в коде компонента страницы About. Так, при загрузке подстраниц, не будет заново отрисовываться вся страница, а только её нижняя часть с разметкой подстраниц. Компоненты Suspense в SharedLayout и About не мешают друг другу, вместо этого React использует наиболее подходящий - тот, что ближе всего к загружаемому компоненту.