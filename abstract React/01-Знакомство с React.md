Веб-приложения
В современной веб-разработке изменились не только техники позволяющие веб-сайтам выглядеть лучше, загружаться быстрее и быть приятнее в использовании. В первую очередь изменились фундаментальные вещи - то, как мы проектируем и создаем веб-приложения.

Возьмем произвольный веб-сайт, например для работы с коллекцией рецептов, расписанием тренировок и т. п. Всегда есть какой-то набор страниц, например домашняя, профиль, страница коллекции и страница деталей элемента коллекции.

Web application
Multiple-page Application
Раньше мы бы использовали подход включающий несколько отдельных HTML-страниц.

Multiple page application
Архитектура клиент-сервер
За всю логику отвечает бэкенд
На каждый запрос бэкенд отсылает готовый HTML-документ
Перезагрузка страницы при каждом запросе
Плохая интерактивность
Отличное SEO
Single-page Application
Современный подход - сайт, на котором пользователь никогда не переходит на другие HTML-страницы. Интерфейс, вместо запроса HTML-документов с сервера, перерисовывается на клиенте, на одной и той же странице, без перезагрузки.

Single page application
Архитектура клиент-сервер
При загрузке сайта бэкенд всегда отдает стартовую HTML-страницу index.html
Каждый последующий запрос на бэкенд получает только данные в JSON-формате
Обновление интерфейса происходит динамически в браузере
Загрузка первой страницы может быть довольно медленной
За логику не связанную с безопасностью отвечает клиент
Слабое SEO
Сложность кода и его поддержки масштабируется с кол-вом функционала приложения

Библиотека React
cover
React это библиотека для создания элементов пользовательского интерфейса. В нем нет встроенной маршрутизации, HTTP-модуля и т. п. Тем не менее есть богатая экосистема, которая позволит решить любую задачу.

При создании приложения с использованием React, разработчик не взаимодействует с DOM-деревом напрямую. Его задача описать интерфейс с помощью компонентов (шаблон) и управлять изменением данных (модель). React, при изменении данных модели, сам обновит интерфейс по шаблону.

React мультиплатформенный, HTML-разметку можно рендерить на сервере (Next.js), писать нативные (React Native) или десктопные (Electron) приложения.

Browser DOM и Virtual DOM
Browser DOM - древовидное представление HTML-документа, где каждый элемент документа представлен в виде DOM-узла. Хранится в браузере и напрямую связан с тем что мы видим на странице.

При каждом изменении DOM, браузер выполняет несколько трудоемких операций. Частые операции обновления такого дерева негативно влияют на производительность и отзывчивость интерфейса. Поэтому он медленный и обновлять его необходимо эффективно.

browser rendering flow
Virtual DOM - абстракция, легковесная копия реального DOM-дерева в виде JSON-объекта.

Существует только в памяти и не рендерится в браузере
Не зависит от внутренней имплементации браузера
Использует лучшие практики обновления реального DOM
Собирает обновления в группы для оптимизации рендеринга (batching)
Алгоритм обновления DOM
В React каждый элемент интерфейса это компонент (кастомный или встроенный), который зависит от пропсов или состояния, и представлен узлами виртуального DOM-дерева. Взаимодействие пользователя с интерфейсом изменяет состояние приложения.

image
При изменении компонента создается новое виртуальное DOM-дерево. Далее, используя алгоритм поиска в ширину (breadth-first), происходит сравнение (дифференцирование, diffing) двух виртуальных деревьев - до и после обновления.

breadth-first алгоритм
Красные узлы представляют элементы, которые изменились. Вычисляется разница между предыдущей и новой версией виртуального DOM-дерева. Применяется оптимальный вариант внесения изменений в реальный DOM. Это гарантирует, что в реальном DOM-дереве производится минимальное количество обновлений, тем самым повышая производительность интерфейса.

dom-update-chain
ДЕТАЛЬНЕЕ
Этот механизм называется согласование (reconciliation). Начинающему разработчику не нужно беспокоиться о том, как именно обновляется интерфейс. Тем не менее, если вам интересно узнать больше, рекомендуем ознакомиться с официальной документацией.

Инструменты
Для создания React-приложения необходимы Node.js, Webpack, Babel, ESLint, React и DevTools. Можно написать свою Webpack-сборку или взять любую популярную с GitHub.

Create React App
Для маленьких и средних проектов рекомендуется использовать утилиту от авторов React. Обязательно ознакомьтесь с документацией Create React App.

Абстрагирует всю конфигурацию, позволяя сосредоточиться на написании кода
Включает необходимые инструменты: Webpack, Babel, ESLint и т. п.
Расширяется дополнительными пакетами из экосистемы React
Имеет функцию извлечения, которая удаляет абстракцию и открывает конфигурацию
Выполните следующую команду в терминале чтобы запустить создание стартовых файлов проекта.

npx create-react-app имя_папки_проекта

Для того чтобы создать приложение в текущей папке, вместо имени проекта ставится точка. Например npx create-react-app .. Это можно использовать когда был клонирован репозиторий и в его локальной версии инициализируется приложение.

NPX
Инструмент, предназначенный стандартизировать использование npm-пакетов. Поставляется с npm версии 5.2.0 и выше. npm управляет зависимостями, размещенными в реестре, a npx упрощает использование CLI-утилит и других исполняемых файлов без необходимости их установки в систему или проект.

React DevTools
В инструментах разработчика можно посмотреть на дерево компонентов, их состояние и пропсы. Профайлер полезен при оптимизации приложения.

JSX
const link = <a href="https://reactjs.org/">React website</a>;

Это не строка и не HTML, этот XML-образный синтаксис называется JSX (JavaScript Syntax Extension) - расширение синтаксиса JavaScript, при помощи которого удобно описывать разметку того, что мы хотим увидеть на экране.

Позволяет использовать XML-образный синтаксис прямо в JavaScript
Упрощает код, делает его декларативным и читабельным
Описывает объекты - элементы Virtual DOM
Это не HTML, Babel трансформирует JSX в вызовы функций
В JSX можно использовать все возможности JavaScript
REACT ЭЛЕМЕНТЫ
JSX создает элементы - самые маленькие строительные блоки React. Элементы Virtual DOM это обычные JavaScript объекты, поэтому создавать их очень быстро.

Используя JSX, разметка становится похожа на привычные HTML-шаблоны.

src/index.js
const imageUrl =
  "https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640";
const productPrice = 10.99;
const product = (
  <div>
    <img src={imageUrl} alt="Tacos With Lime" width="640" />
    <h2>Tacos With Lime</h2>
    <p>Price: {productPrice}$</p>
    <button type="button">Add to cart</button>
  </div>
);

Внутри JSX можно использовать любое валидное выражение, оборачивая его в фигурные скобки.
Значения атрибутов указываются в двойных кавычках, если это обычная строка, и в фигурных скобках, если значение вычисляется, либо тип отличается от строки.
Все атрибуты React-элементов именуются в camelCase нотации.
JSX-теги могут быть родителями других JSX-тегов. Если тег пустой или самозакрывающийся, его обязательно необходимо закрыть используя />.
Рендер элементов в DOM-дерево
Для того чтобы отрендерить элемент в DOM-дерево, в пакете react-dom есть методы createRoot(container) и render(element), которые работают вместе.

Первый принимает ссылку на существующий DOM-элемент, например div#root из index.html и создаёт корень в который будет рендерится все приложение.
Второй ожидает ссылку на React-элемент или компонент (что рендерить)
src/index.js
import ReactDOM from "react-dom/client";
const imageUrl =
  "https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640";
const productPrice = 10.99;
const product = (
  <div>
    <img src={imageUrl} alt="Tacos With Lime" width="640" />
    <h2>Tacos With Lime</h2>
    <p>Price: {productPrice}$</p>
    <button type="button">Add to cart</button>
  </div>
);
ReactDOM.createRoot(document.getElementById("root")).render(product);

ОДИН render() НА ПРИЛОЖЕНИЕ
React использует модель отношений предок - потомок, поэтому достаточно использовать только один вызов render() в приложении. Рендер самого верхнего элемента в иерархии повлечет за собой рендер всего поддерева.

Правило общего родителя
Правая часть выражения присваивания должна возвращать одно значение. Разберем следующий код с невалидной JSX-разметкой.

const post = (
  <h2>Post Header</h2>
  <p>Post text</p>
);

Выражение это одно значение, результат неких вычислений, отсюда вытекает правило общего родителя.

const post = (
  <div>
    <h2>Post Header</h2>
    <p>Post text</p>
  </div>
);

Если в разметке лишний тег-обертка не нужен, используются фрагменты, похожие на DocumentFragment. Этот встроенный компонент при рендере растворяется, подставляя свое содержимое.

import { Fragment } from "react";

const post = (
  <Fragment>
    <h2>Post Header</h2>
    <p>Post text</p>
  </Fragment>
);

Синтаксис фрагментов можно сократить и не добавлять импорт Fragment. Babel сделает все необходимые трансформации, заменив пустые JSX-теги на React.Fragment.

const post = (
  <>
    <h2>Post Header</h2>
    <p>Post text</p>
  </>
);

Дополнительные материалы:
https://reactjs.org/docs/introducing-jsx.html
https://reactjs.org/docs/dom-elements.html#differences-in-attributes
https://reactjs.org/docs/rendering-elements.html


Компоненты
Компоненты - основные строительные блоки React-приложений, при помощи которых интерфейс делится на независимые части.

Разработчик создает небольшие компоненты, которые можно объединять, чтобы сформировать более крупные или использовать их как самостоятельные элементы интерфейса. Самое главное в этой концепции то, что и большие, и маленькие компоненты можно использовать повторно и в текущем и в новом проекте.

components
React-приложение можно представить как дерево компонентов. На верхнем уровне стоит корневой компонент, в котором вложено произвольное количество других компонентов. Каждый компонент должен вернуть JSX-разметку, тем самым указывая какой HTML мы хотим отрендерить в DOM.

Компоненты-функции
В простейшей форме компонент это JavaScript-функция с очень простым контрактом: функция получает объект свойств который называется props и возвращает дерево React-элементов.

functional component
ИМЯ КОМПОНЕНТА
Имя компонента обязательно должно начинаться с заглавной буквы. Названия компонентов с маленькой буквы зарезервированы для HTML-элементов. Если вы попробуете назвать компонент card, а не Card, при рендере, React проигнорирует его и создаст тег <card></card>.

const MyFunctionalComponent = props => <div>Functional Component</div>;

Компоненты-функции составляют большую часть React-приложения.

Меньше boilerplate-кода
Легче воспринимать
Легче тестировать
Нет контекста (this)
Сделаем карточку продукта компонентом-функцией.

const Product = props => (
  <div>
    <img
      src="https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640"
      alt="Tacos With Lime"
      width="640"
    />
    <h2>Tacos With Lime</h2>
    <p>Price: 10.99$</p>
    <button type="button">Add to cart</button>
  </div>
);

// В разметке компонент записывается как JSX-тег
ReactDOM.createRoot(document.getElementById("root")).render(<Product />);

Свойства компонента (props)
Свойства (пропсы) это одна из основных концепций React. Компоненты принимают произвольные свойства и возвращают React-элементы, описывающие что должно отрендерится в DOM.

Используются для передачи данных от родителя к ребенку.
Передаются только вниз по дереву от родительского компонента.
При изменении пропсов React повторно рендерит компонент и, возможно, обновляет DOM.
Пропсы доступны только для чтения, изменить их в ребенке нельзя.
props
Пропсом может быть текст кнопки, картинка, url, любые данные для компонента. Пропсы могут быть строками или результатом JS-выражения. Если передано только имя пропса - это буль, по умолчанию true.

const App = () => (
  <>
    <h1>Best selling products</h1>
    <Product name="Tacos With Lime" />
  </>
);

Компонент <Product> объявляет параметр props, это всегда будет объект содержащий все переданные пропсы.

const Product = props => (
  <div>
    <h2>{props.name}</h2>
  </div>
);

Добавим компоненту <Products> несколько других свойств.

const Product = props => (
  <div>
    <img src={props.imgUrl} alt={props.name} width="640" />
    <h2>{props.name}</h2>
    <p>Price: {props.price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

Сразу будем использовать простой паттерн при работе с props. Так как props это объект, мы можем деструктуризировать его в подписи функции. Это сделает код чище и читабельнее.

const Product = ({ imgUrl, name, price }) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

const App = () => (
  <div>
    <h1>Best selling products</h1>
    <Product
      imgUrl="https://images.pexels.com/photos/461198/pexels-photo-461198.jpeg?dpr=2&h=480&w=640"
      name="Tacos With Lime"
      price={10.99}
    />
    <Product
      imgUrl="https://images.pexels.com/photos/70497/pexels-photo-70497.jpeg?dpr=2&h=480&w=640"
      name="Fries and Burger"
      price={14.29}
    />
  </div>
);

В результате мы создали настраиваемый компонент который можно использовать для отображения товара. Мы передаем ему данные как пропсы, а в ответ получаем дерево React-элементов с подставленными значениями.

Компоненты и пропсы
JSX в деталях
Spread Attributes
Значение пропсов по умолчанию
Что если компонент ожидает какое-то значение, а его не передали? - при обращении к свойству объекта props, получим undefined.

Для того чтобы указать значения свойств по умолчанию, используется синтаксис значений по умолчанию при деструктуризации пропсов.

const Product = ({
  imgUrl = "https://dummyimage.com/640x480/2a2a2a/ffffff&text=Product+image+placeholder",
  name,
  price,
}) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

/*
 * Определение defaultProps гарантирует, что props.imgUrl будет иметь значение,
 * даже если оно не было передано при использовании компонента в родителе.
 */
ReactDOM.createRoot(document.getElementById("root")).render(
  <Product name="Tacos With Lime" price={10.99} />
);

Свойство children
Концепция дочерних элементов позволяет очень просто делать композицию компонентов. В виде детей можно передавать компоненты, как встроенные так и кастомные. Это очень удобно при работе со сложными составными компонентами.

Свойство children автоматически доступно в каждом компоненте, его содержимым является то, что стоит между открывающим и закрывающим JSX-тегом.
В функциональных компонентах обращаемся как props.children.
Значением props.children может быть практически что угодно.
К примеру у нас есть компонент профиля <Profile> и компонент секции <Panel>, в который мы можем помещать произвольный контент.

const Profile = ({ name, email }) => (
  <div>
    <p>Name: {name}</p>
    <p>Email: {email}</p>
  </div>
);

const Panel = ({ title, children }) => (
  <section>
    <h2>{title}</h2>
    {children}
  </section>
);

const App = () => (
  <div>
    <Panel title="User profile">
      <Profile name="Mango" email="mango@mail.com" />
    </Panel>
  </div>
);

В противном случае нам бы пришлось пробросить пропы для <Profile> сквозь <Panel>, что более тесно связывает компоненты и усложняет повторное использование.

Свойство propTypes
Проверка типов получаемых пропсов позволит отловить много ошибок. Это экономит время, помогает при невнимательности и спасает при росте приложения. В будущем будет необходимо выделить время и познакомиться с TypeScript, а для старта хватит небольшой библиотеки.

Пакет prop-types предоставляет ряд валидаторов для проверки корректности полученных типов данных во время исполнения кода, уведомляя о несоответствиях в консоли. Все что необходимо сделать это описать типы пропсов получаемых компонентом в специальном статическом свойстве propTypes. Проверка пропсов с помощью prop-types происходит только во время разработки, в продакшене в ней нет необходимости.

npm install --save-dev prop-types

Используем prop-types и опишем пропсы компонента Product.

import PropTypes from "prop-types";

const Product = ({
  imgUrl = "https://dummyimage.com/640x480/2a2a2a/ffffff&text=Product+image+placeholder",
  name,
  price,
}) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <button type="button">Add to cart</button>
  </div>
);

Product.propTypes = {
  imgUrl: PropTypes.string,
  name: PropTypes.string.isRequired,
  price: PropTypes.number.isRequired,
};

Сначала применяются значения по умолчанию, заданные в defaultProps. После запускается проверка типов с помощью propTypes. Так что проверка типов распространяется и на значения по умолчанию.

Проверка типов с помощью PropTypes https://reactjs.org/docs/typechecking-with-proptypes.html

Рендер по условию
Для рендера разметки по условию используются операторы ветвлений и условий. Условия можно проверять перед возвратом разметки, или прямо в JSX.

ПУСТЫЕ ЗНАЧЕНИЯ
Если по условию ничего не должно быть отрендерено, можно вернуть null, undefined или false, они не рендерятся.

if с помощью логического оператора &&
Читается как: если условие приводится к true, то рендерим разметку.

const Mailbox = ({ unreadMessages }) => {
  return (
    <div>
      <h1>Hello!</h1>
      {unreadMessages.length > 0 && (
        <p>You have {unreadMessages.length} unread messages.</p>
      )}
    </div>
  );
};

if...else с помощью тернарного оператора
Читается как: если условие приводится к true, рендерим разметку после ?, в противном случае рендерим разметку после :.

const Mailbox = ({ username, unreadMessages }) => {
  return (
    <div>
      <h1>Hello {username}</h1>
      {unreadMessages.length > 0 ? (
        <p>You have {unreadMessages.length} unread messages.</p>
      ) : (
        <p>No unread messages.</p>
      )}
    </div>
  );
};

Последний пример можно записать по другому, результат будет одинаковый.

const Mailbox = ({ name, unreadMessages }) => {
  return (
    <div>
      <h1>Hello {name}</h1>
      <p>
        {unreadMessages.length > 0
          ? `You have ${unreadMessages.length} unread messages.`
          : "No unread messages."}
      </p>
    </div>
  );
};

Пусть в компоненте продукта еще есть его доступное количество.

const Product = ({ imgUrl, name, price, quantity }) => (
  <div>
    <img src={imgUrl} alt={name} width="640" />
    <h2>{name}</h2>
    <p>Price: {price}$</p>
    <h1>Quantity: {quantity < 20 ? "Few left" : "In stock"}</h1>
    <button type="button">Add to cart</button>
  </div>
);

Дополинтельные материалы
Условный рендеринг https://reactjs.org/docs/conditional-rendering.html
All the Conditional Renderings in React https://www.robinwieruch.de/conditional-rendering-react/

Коллекции
Для того чтобы отрендерить коллекцию однотипных элементов, используется метод Array.prototype.map(), callback-функция которого, для каждого элемента коллекции, возвращает JSX-разметку. Таким образом получаем массив React-элементов который можно рендерить.

const favoriteBooks = [
  { id: "id-1", name: "JS for beginners" },
  { id: "id-2", name: "React basics" },
  { id: "id-3", name: "React Router overview" },
  { id: "id-4", name: "Redux in depth" },
];

const BookList = ({ books }) => {
  return (
    <ul>
      {books.map(book => (
        <li>{book.name}</li>
      ))}
    </ul>
  );
};

const App = () => {
  return (
    <div>
      <BookList books={favoriteBooks} />
    </div>
  );
};

Ключи
При выполнении кода из примера выше, всплывет предупреждение о том, что для элементов списка требуется ключ. React не может отличить элементы в коллекции, таким образом, перерисовывая всю коллекцию целиком при любых изменениях.

Ключ (key) — это специальный строковый проп, который нужно задать при создании элементов коллекции.

Элементы внутри коллекции должны быть обеспечены ключами, чтобы иметь стабильную идентичность. React использует ключи, чтобы определить, какие из элементов в коллекции необходимо создать и отрендерить заново, а не использовать элементы из предыдущего рендера. Так мы избегаем пересоздания всех элементов коллекции каждый раз, когда что-то меняется.

Ключи должны быть:

Уникальные - ключ элемента должен быть уникальным только среди его соседей. Нет смысла в глобально уникальных ключах.
Стабильные - ключ элемента не должен меняться со временем, изменением порядка элементов или после обновления страницы.
INFO
Индексы массива уникальны, однако они не стабильны, при перетасовке коллекции ключи меняются. Дата и время уникальны, но не стабильны, так как постоянно увеличиваются. Таким образом, при каждом рендере получаются новые ключи. Использование случайного числа равносильно тому, что ключи вообще не используются, поскольку случайные числа не являются уникальными или стабильными.

Лучший способ задать ключ - использовать статическую строку, которая однозначно идентифицирует элемент списка среди остальных. Чаще всего в качестве ключей используются идентификаторы объектов созданных базой данных - постоянное, неизменное значение. Но также подойдет любое уникальное значение какого-то свойства объекта.

const favoriteBooks = [
  { id: "id-1", name: "JS for beginners" },
  { id: "id-2", name: "React basics" },
  { id: "id-3", name: "React Router overview" },
  { id: "id-4", name: "Redux in depth" },
];

const BookList = ({ books }) => (
  <ul>
    {books.map(book => (
      <li key={book.id}>{book.name}</li>
    ))}
  </ul>
);

Если у объектов массива нет уникальных значений свойств и коллекция не редактируемая, то есть у пользователя нет возможности удалить или еще как либо изменить порядок элементов, кроме добавление новых, можно использовать индексы массива.

const favoriteBooks = [
  { name: "JS for beginners" },
  { name: "React basics" },
  { name: "React Router overview" },
  { name: "Redux in depth" },
];

const BookList = ({ books }) => (
  <ul>
    {books.map((book, index) => (
      <li key={index}>{book.name}</li>
    ))}
  </ul>
);

ИНДЕКСЫ КАК КЛЮЧИ
Использование индексов для ключей это крайний случай. В подавляющем большинстве данных будут уникальные идентификаторы или какие-либо другие свойства.

Дополнительные материалы
Списки и ключи https://reactjs.org/docs/lists-and-keys.html
